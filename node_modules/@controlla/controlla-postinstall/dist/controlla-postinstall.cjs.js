'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var consola = _interopDefault(require('consola'));
var child_process = require('child_process');
var chalk = _interopDefault(require('chalk'));
var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs'));
var fetch = _interopDefault(require('node-fetch'));

const reportAndThrowError = msg => {
  report(msg);
  throw new Error(msg);
};
const report = message => {
  consola.debug({
    message: String(message),
    tag: 'controlla'
  });
};
const hideMessage = (env = process.env) => {
  // Show message if it is forced
  if (env.CONTROLLA_FORCE) {
    return false;
  } // Don't show after oracle postinstall


  if (env.OC_POSTINSTALL_TEST) {
    return true;
  } // Don't show if opted-out


  if (env.CONTROLLA_HIDE) {
    return true;
  } // Compatability with controlla-postinstall


  if (!!env.DISABLE_CONTROLLA && env.DISABLE_CONTROLLA !== '0' && env.DISABLE_CONTROLLA !== 'false') {
    return true;
  } // Don't show if on CI


  if (env.CI || env.CONTINUOUS_INTEGRATION) {
    return true;
  } // Only show in dev environment


  return Boolean(env.NODE_ENV) && !['dev', 'development'].includes(env.NODE_ENV);
};
const formatMoney = currency => amount => {
  amount = amount / 100; // converting cents

  const precision = 0;
  return amount.toLocaleString(currency, {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: precision,
    maximumFractionDigits: precision
  });
};
const isWin32 = process.platform === 'win32';

/* eslint-disable no-console */
const print = (color = null) => (str = '') => {
  const terminalCols = retrieveCols();
  const strLength = str.replace(/\u001b\[[0-9]{2}m/g, '').length;
  const leftPaddingLength = Math.floor((terminalCols - strLength) / 2);
  const leftPadding = ' '.repeat(Math.max(leftPaddingLength, 0));

  if (color) {
    str = chalk[color](str);
  }

  console.log(leftPadding, str);
};
const retrieveCols = (() => {
  let result = false;
  return () => {
    if (result) {
      return result;
    }

    const defaultCols = 80;

    try {
      const terminalCols = child_process.execSync(`tput cols`, {
        stdio: ['pipe', 'pipe', 'ignore']
      });
      result = parseInt(terminalCols.toString()) || defaultCols;
    } catch (e) {
      result = defaultCols;
    }

    return result;
  };
})();
const printStats = (stats, color) => {
  if (!stats) {
    return;
  }

  const colored = print(color);
  const bold = print('bold');
  const formatWithCurrency = formatMoney(stats.currency);
  colored(`Number of contributors: ${stats.contributorsCount}`);
  colored(`Number of backers: ${stats.backersCount}`);
  colored(`Annual budget: ${formatWithCurrency(stats.yearlyIncome)}`);
  bold(`Current balance: ${formatWithCurrency(stats.balance)}`, 'bold');
};
const printLogo = logoText => {
  if (!logoText) {
    return;
  }

  logoText.split('\n').forEach(print('yellow'));
};
/**
 * Only show emoji on OSx (Windows shell doesn't like them that much ¯\_(ツ)_/¯ )
 * @param {*} emoji
 */

const emoji = emoji => process.stdout.isTTY && !isWin32 ? emoji : '';
function printFooter(controlla) {
  const dim = print('dim');
  const yellow = print('yellow');
  const emptyLine = print();
  yellow(`Thanks for installing ${controlla.slug} ${emoji('🙏')}`);
  dim(`Please consider donating to our open controlla`);
  dim(`to help us maintain this package.`);
  emptyLine();
  printStats(controlla.stats);
  emptyLine();
  print()(`${chalk.bold(`${emoji('👉 ')} ${controlla.donationText}`)} ${chalk.underline(controlla.donationUrl)}`);
  emptyLine();
}

const FETCH_TIMEOUT = 3000;
const fetchLogo = logoUrl => new Promise(function ($return, $error) {
  if (!logoUrl) {
    // Silent return if no logo has been provided
    return $return();
  }

  if (!logoUrl.match(/^https?:\/\//)) {
    reportAndThrowError(`Your logo URL isn't well-formatted - ${logoUrl}`);
  }

  var $Try_3_Post = function () {
    try {
      return $return();
    } catch ($boundEx) {
      return $error($boundEx);
    }
  };

  var $Try_3_Catch = function (e) {
    try {
      report(`Error while fetching logo from ${logoUrl}`);
      return $Try_3_Post();
    } catch ($boundEx) {
      return $error($boundEx);
    }
  };

  try {
    let res;
    return Promise.resolve(global.fetch(logoUrl, {
      timeout: FETCH_TIMEOUT
    })).then(function ($await_7) {
      try {
        res = $await_7;

        if (isLogoResponseWellFormatted(res)) {
          return $return(res.text());
        }

        report(`Error while fetching logo from ${logoUrl}. The response wasn't well-formatted`);
        return $Try_3_Post();
      } catch ($boundEx) {
        return $Try_3_Catch($boundEx);
      }
    }, $Try_3_Catch);
  } catch (e) {
    $Try_3_Catch(e);
  }
});

const isLogoResponseWellFormatted = res => res.status === 200 && res.headers.get('content-type').match(/^text\/plain/);

const fetchPkg = pathToPkg => {
  const fullPathToPkg = path.resolve(`${pathToPkg}/package.json`);

  try {
    return JSON.parse(fs.readFileSync(fullPathToPkg, 'utf8'));
  } catch (e) {
    reportAndThrowError(`Could not find package.json at ${fullPathToPkg}`);
  }
};

const controllaUrl = pkg => {
  const url = pkg.controlla && pkg.controlla.url;

  if (!url) {
    reportAndThrowError('No controlla URL set!');
  }

  return url;
}; // use pkg.controlla.logo for "legacy"/compatibility reasons

const controllaLogoUrl = pkg => pkg.controlla.logo || pkg.controlla.logoUrl || false;
const controllaDonationText = pkg => pkg.controlla.donation && pkg.controlla.donation.text || 'Visit:';
const getControlla = pkgPath => new Promise(function ($return, $error) {
  let pkg, url, baseControlla, logoUrl, logo;
  pkg = fetchPkg(pkgPath);
  url = controllaUrl(pkg);
  baseControlla = {
    url,
    slug: pkg.name,
    logoUrl: controllaLogoUrl(pkg),
    donationUrl: controllaDonationUrl(pkg),
    donationText: controllaDonationText(pkg)
  };
  logoUrl = baseControlla.logoUrl;
  return Promise.resolve(fetchLogo(logoUrl)).then(function ($await_1) {
    try {
      logo = $await_1;
      return $return(Object.assign(baseControlla, {
        logo
      }));
    } catch ($boundEx) {
      return $error($boundEx);
    }
  }, $error);
});
const controllaDonationUrl = pkg => {
  const defaultDonationAmount = pkg.controlla.donation && pkg.controlla.donation.amount;
  let donateUrl = `${controllaUrl(pkg)}/`;

  if (defaultDonationAmount) {
    return `${donateUrl}${defaultDonationAmount}`;
  }

  return donateUrl;
};

function init(path$$1, hide = hideMessage()) {
  return new Promise(function ($return, $error) {
    let controlla;

    if (hide) {
      return $return();
    }

    global.fetch = global.fetch || fetch;
    return Promise.resolve(getControlla(path$$1)).then(function ($await_1) {
      try {
        controlla = $await_1;
        printLogo(controlla.logo);
        printFooter(controlla);
        return $return();
      } catch ($boundEx) {
        return $error($boundEx);
      }
    }, $error);
  });
}

exports.init = init;
